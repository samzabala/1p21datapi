(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.dataVisualizer = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _readOnlyError(name) {
    throw new Error("\"" + name + "\" is read-only");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = privateMap.get(receiver);

    if (!descriptor) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }

    return descriptor.value;
  }

  function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = privateMap.get(receiver);

    if (!descriptor) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        throw new TypeError("attempted to set read only private field");
      }

      descriptor.value = value;
    }

    return value;
  }

  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }

    return method;
  }

  function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return fn;
  }

  var Component = /*#__PURE__*/function () {
    function Component(dv, props) {
      _classCallCheck(this, Component);

      if (!dv) {
        return;
      }

      this.dv = dv;

      if (_typeof(props) === 'object') {
        for (var key in props) {
          this[key] = props[key];
        }
      }
    }

    _createClass(Component, [{
      key: "dispose",
      value: function dispose() {
        this.dv = null;
      }
    }]);

    return Component;
  }();

  //sana 2d lang
  var Coordinates = ['x', 'y']; //kwan has scales domains and shit

  var DatumKeys$1 = [0, 1, 'color', 'area'];
  /*****************************************************************************
   *DATA HELPEE
  *****************************************************************************/
  // kinkily get data but with aility to get down deep because we never know where the fuck the date will be at
  // @param obj : duh 
  // @param keystring : hooman provided object key string that is hopefully correct 
  // @param isNum : if the data is a number
  //kinkily merge defaults with custom

  var DeepValidate = function DeepValidate(defaults, arr) {
    var args = defaults;
    Object.keys(arr).forEach(function (prop, i) {
      //ha?
      if (prop == 'key' || prop == 'reverse') {
        // if(Object.prototype.toString.call(arr[prop]) == '[object Object]'){
        args[prop] = DeepValidate(args[prop], arr[prop]);
      } else if (arr.hasOwnProperty.call(arr, prop)) {
        // Push each value from `obj` into `extended`
        args[prop] = arr[prop];
      }
    });
    return args;
  }; //get the length attribute to associate with the axis bro

  var ToSide = function ToSide(axisName, opposite) {
    return opposite ? axisName == 'x' ? 'height' : 'width' : axisName == 'x' ? 'width' : 'height';
  };
  var ToOppoAxis = function ToOppoAxis(axisName) {
    return axisName == 'x' ? 'y' : 'x';
  }; //d3 does not support ie 11. kill it

  var VaildateBrowser = function VaildateBrowser() {
    var ua = navigator.userAgent;
    return ua.indexOf("MSIE ") > -1 || ua.indexOf("Trident/") > -1;
  }; //string helpers

  var Str = {
    // duh
    fileExtension: function fileExtension(str) {
      return str.split('.').pop();
    },
    // convert boi to 
    hash: function hash(str) {
      var url = str;
      var type = url.split('#');
      var hash = type[type.length - 1] || '';
      return hash;
    },
    // is dis json enough for u?
    IsValidJSONString: function IsValidJSONString(str) {
      try {
        JSON.parse(str);
      } catch (e) {
        return false;
      }

      return true;
    },
    //kemel
    toCamelCase: function toCamelCase(str) {
      return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
        return index == 0 ? word.toLowerCase() : word.toUpperCase();
      }).replace(/\s+/g, '');
    },
    //duh
    toCapitalize: function toCapitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
  };
  var ColorIsDark = function ColorIsDark(hexString) {
    // Variables for red, green, blue values
    var r, g, b, hsp; // Check the format of the hexString, HEX or RGB?

    if (hexString.match(/^rgb/)) {
      // If HEX --> store the red, green, blue values in separate variables
      hexString = hexString.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
      r = hexString[1];
      g = hexString[2];
      b = hexString[3];
    } else {
      // If RGB --> Convert it to HEX: http://gist.github.com/983661
      hexString = +("0x" + hexString.slice(1).replace(hexString.length < 5 && /./g, '$&$&'));
      r = hexString >> 16;
      g = hexString >> 8 & 255;
      b = hexString & 255;
    } // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html


    hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b)); // Using the HSP value, determine whether the hexString is light or dark

    if (hsp > 170) {
      //127.5
      return false;
    } else {
      return true;
    }
  };
  var ValidMargin = function ValidMargin(variable) {
    if (typeof variable === 'number') {
      return variable;
    }
  };
  var GetNearest = function GetNearest(num) {
    if (num > 10) {
      return Math.pow(10, num.toString().length - 1) * 10;
    } else {
      return 1;
    }
  };

  var Axis = /*#__PURE__*/function (_Component) {
    _inherits(Axis, _Component);

    var _super = _createSuper(Axis);

    function Axis(dv, axisName) {
      _classCallCheck(this, Axis);

      return _super.call(this, dv, {
        axisName: axisName
      });
    }

    _createClass(Axis, [{
      key: "amount",
      value: function amount(isGrid) {
        var dv = this.dv;
        var axisName = this.axisName;

        if (isGrid && dv.args("".concat(axisName, "TicksAmount"))) {
          return dv.args("".concat(axisName, "TicksAmount")) * dv.args("".concat(axisName, "GridIncrement"));
        } else {
          return dv.args("".concat(axisName, "TicksAmount"));
        }
      }
    }, {
      key: "values",
      value: function values() {
        var dv = this.dv;
        var values = [],
            currVal = dv.domain(0)[0];

        do {
          values.push(currVal);
          currVal *= 10;
        } while (currVal <= dv.domain(1).values);

        return values;
      }
    }, {
      key: "getCall",
      value: function getCall(isGrid) {
        isGrid = isGrid || false;
        var dv = this.dv;
        var axisName = this.axisName;
        var d3AxisKey = 'Axis ' + dv.args("".concat(axisName, "Align"));
        var toReturn = d3[Str.toCamelCase(d3AxisKey)](dv.scale(dv.args("".concat(this.axisName, "Data"))));

        if (dv._is_base('scatter') && dv.args("".concat(axisName, "Data")) == 0 && dv._name_is_num == true) {
          toReturn.tickValues(this.values());
        }

        if (dv._has_axis_prop('ticksAmount', axisName)) {
          toReturn.ticks(this.amount(isGrid));
        }

        if (isGrid) {
          toReturn.tickSize(dv.args(ToSide(axisName, true)) * -1).tickFormat("");
        } else {
          toReturn.tickFormat(function (dis, i) {
            return dv.format(dv.args("".concat(axisName, "Data")))(dis, i);
          });
        }

        return toReturn;
      }
    }]);

    return Axis;
  }(Component);

  var Shape = /*#__PURE__*/function (_Component) {
    _inherits(Shape, _Component);

    var _super = _createSuper(Shape);

    function Shape(dv, dis, i) {
      _classCallCheck(this, Shape);

      return _super.call(this, dv, {
        dis: dis,
        i: i
      });
    }

    _createClass(Shape, [{
      key: "dimension",
      value: function dimension(axisName) {
        return this.dv.args(ToSide(axisName));
      }
    }, {
      key: "coordAttr",
      value: function coordAttr(axisName) {
        var dv = this.dv;
        return dv._is_base(['line', 'scatter']) ? "c".concat(axisName) : "".concat(axisName);
      }
    }, {
      key: "radius",
      value: function radius(initial) {
        var dv = this.dv;
        var dis = this.dis;
        var i = this.i;
        initial = initial || false;
        var radius = initial ? 0 : dv._is_base('scatter') ? (dv.args('areaMin') + dv.args('areaMax')) / 2 : 5;

        if (!initial) {
          if (dv._is_base('line')) {
            if (dv._is_base('line') && dv.args('linePointsSize')) {
              radius = args.linePointsSize;
            }
          } else if (dv._is_base('scatter') && dv.args("key['area']")) {
            radius = dv.scale('area', dv._get(dis, dv.args("key['area']"), true));
          }
        }

        return radius;
      }
    }, {
      key: "scaledValue",
      value: function scaledValue(keyKey) {
        var dv = this.dv;
        var dis = this.dis;
        var dataToScale;

        if (dv._name_is_num == true || keyKey == 1) {
          dataToScale = dv._get(dis, dv.args("key['".concat(keyKey, "']")), true);
        } else {
          dataToScale = dv._get(dis, dv.args("key['".concat(keyKey, "']")), false);
        }

        return dv.scale(keyKey, dataToScale);
      }
    }, {
      key: "size",
      value: function size(coord, initial) {
        initial = initial || false;
        var dv = this.dv;
        var dis = this.dis;
        var i = this.i;

        if (dv._is_base('pie')) {
          return; //go on pi. git. u have no bidnes herr
        }

        var toReturn = 20;
        var keyKey = dv.args("".concat(coord, "Data")),
            oppoAlign = dv.args("".concat(ToOppoAxis(coord), "Align"));

        if (dv._name_is_num == true || keyKey == 1) {
          if (initial) {
            toReturn = 0;
          } else {
            if (oppoAlign == 'right' || oppoAlign == 'bottom') {
              toReturn = this.dimension(coord) - this.scaledValue(keyKey);
            } else {
              toReturn = this.scaledValue(keyKey);
            }
          }
        } else {
          toReturn = dv.scale(keyKey).bandwidth();
        } //cant be a negaative bitch what the fuq


        if (toReturn < 0) {
          toReturn = 0;
        }

        return toReturn;
      }
    }, {
      key: "offset",
      value: function offset(coord, initial) {
        initial = initial || false;
        var dv = this.dv;
        var dis = this.dis;
        var i = this.i;

        if (dv._is_base('pie')) {
          return; //go on pi. git. u have no bidnes herr
        } // same here.. could be the same probably


        var keyKey = dv.args("".concat(coord, "Data")),
            oppoAlign = dv.args("".concat(ToOppoAxis(coord), "Align"));
        var toReturn = 0;

        if (dv._name_is_num == true || keyKey == 1) {
          if (oppoAlign == 'right' || oppoAlign == 'bottom') {
            if (initial && keyKey == 1 && dv._is_base(['bar', 'line'])) {
              toReturn = this.dimension(coord);
            } else {
              toReturn = this.dimension(coord) - this.scaledValue(keyKey);
              console.warn('offe', dis.name, coord, this.dimension(coord), this.scaledValue(keyKey), toReturn);
            }
          } else {
            if (dv._is_base(['line', 'scatter'])) {
              if (!(initial && keyKey == 1 && dv._is_base('line'))) {
                toReturn = this.scaledValue(keyKey);
              }
            }
          }
        } else {
          toReturn = this.scaledValue(keyKey);

          if (dv._is_base(['line', 'scatter']) && !dv._name_is_num) {
            toReturn += this.size(coord) / 2;
          }
        }

        return toReturn;
      }
    }, {
      key: "tag",
      get: function get() {
        var dv = this.dv;

        switch (dv.baseType) {
          case 'bar':
            return 'rect';

          case 'pie':
            return 'path';

          case 'line':
          case 'scatter':
            return 'circle';
        }
      }
    }]);

    return Shape;
  }(Component);

  var OPTIMAL_LABEL_OFFSET_MULTIPLIER = .875;

  var Label = /*#__PURE__*/function (_Component) {
    _inherits(Label, _Component);

    var _super = _createSuper(Label);

    function Label(dv, axisName) {
      _classCallCheck(this, Label);

      return _super.call(this, dv, {
        axisName: axisName
      });
    }

    _createClass(Label, [{
      key: "offset",
      value: function offset(coord) {
        var offset = 0;
        var dv = this.dv;
        var axisName = this.axisName; //x

        if (coord == 'x') {
          if (axisName == 'x') {
            offset = dv.args(ToSide(axisName)) / 2;
          } else if (axisName == 'y') {
            offset = -(dv.args(ToSide(axisName)) / 2);
          }
        } else {
          if (axisName == 'x') {
            if (dv.args("".concat(axisName, "Align")) == 'bottom') {
              offset = dv.args(ToSide(axisName, true)) + dv.margin.bottom * OPTIMAL_LABEL_OFFSET_MULTIPLIER;
            } else {
              offset = -(dv.margin.top * OPTIMAL_LABEL_OFFSET_MULTIPLIER);
            }
          } else if (axisName == 'y') {
            if (dv.args("".concat(axisName, "Align")) == 'right') {
              offset = dv.args(ToSide(axisName, true)) + (dv.margin.right * OPTIMAL_LABEL_OFFSET_MULTIPLIER + dv.fontSize);
            } else {
              offset = -(dv.margin.left * OPTIMAL_LABEL_OFFSET_MULTIPLIER - dv.fontSize);
            }
          }
        }

        return offset;
      }
    }]);

    return Label;
  }(Component);

  var Line = /*#__PURE__*/function (_Component) {
    _inherits(Line, _Component);

    var _super = _createSuper(Line);

    function Line(dv, data) {
      _classCallCheck(this, Line);

      return _super.call(this, dv, {
        data: data
      });
    }

    _createClass(Line, [{
      key: "path",
      value: function path(isArea, initial) {
        var _this = this;

        if (!this.data) {
          return;
        }

        initial = initial || false;
        var dv = this.dv;
        var i = this.i;
        var d3PathType = isArea ? 'area' : 'line';
        var path = d3[d3PathType]();

        if (d3PathType == 'area') {
          //name coord, value coord, fill coordinate
          var aCord = {
            //default is top
            name: this.axisToFill,
            //x
            value: "".concat(ToOppoAxis(this.axisToFill), "1"),
            //y
            fill: "".concat(ToOppoAxis(this.axisToFill), "0") //initial of data name is the bottom of the fill

          };
          path[aCord.name](function (dis, i) {
            return dv.Shape(dis, i).offset(_this.axisToFill, initial);
          })[aCord.value](function (dis, i) {
            return dv.Shape(dis, i).offset(ToOppoAxis(_this.axisToFill), initial);
          })[aCord.fill](function (dis, i) {
            return dv.args("".concat(_this.axisToFill, "Align")) == 'bottom' || dv.args("".concat(_this.axisToFill, "Align")) == 'right' ? dv.args(ToSide(_this.axisToFill)) : 0;
          });
        } else {
          path.x(function (dis, i) {
            return dv.Shape(dis, i).offset('x', initial);
          }).y(function (dis, i) {
            return dv.Shape(dis, i).offset('y', initial);
          });
        }

        path.curve(d3[this.style]);
        return path(this.data);
      }
    }, {
      key: "axisToFill",
      get: function get() {
        return this.dv.args('xData') == 0 ? 'x' : 'y'; //fill to where name data is at
      }
    }, {
      key: "style",
      get: function get() {
        var theString;

        switch (this.dv.args('lineStyle')) {
          case 'step':
            theString = 'curveStepBefore';
            break;

          case 'curve':
            theString = 'curveMonotone' + this.axisToFill.toUpperCase();
            break;

          default:
            theString = 'curveLinear';
            break;
        }

        return theString;
      }
    }]);

    return Line;
  }(Component);

  var OPTIMAL_PI_MULTIPLIER = .5;
  var OPTIMAL_PI_LEGENDARY_MULTIPLIER = .375;

  var Pi = /*#__PURE__*/function (_Component) {
    _inherits(Pi, _Component);

    var _super = _createSuper(Pi);

    function Pi(dv, dis, i) {
      _classCallCheck(this, Pi);

      return _super.call(this, dv, {
        dis: dis,
        i: i
      });
    }

    _createClass(Pi, [{
      key: "offset",
      value: function offset(coord) {
        var dv = this.dv;
        var offset = 0;

        if (dv.args('colorLegend') && coord == 'x') {
          offset = dv.args(ToSide(coord)) * OPTIMAL_PI_LEGENDARY_MULTIPLIER;
        } else {
          offset = dv.args(ToSide(coord)) * OPTIMAL_PI_MULTIPLIER;
        }

        return offset;
      }
    }, {
      key: "path",
      value: function path(calcWithInnerRadius, subMethod, offsetMultiplier, initial) {
        var disPi = this.dis.pie;

        if (!disPi) {
          return;
        } //@TODO ha??


        var dv = this.dv;
        offsetMultiplier = offsetMultiplier || 1;
        subMethod = subMethod || '';
        calcWithInnerRadius = calcWithInnerRadius || false;
        initial = initial || false;
        var innerRadius = calcWithInnerRadius ? this.radius * dv.args("piInRadius") : 0;
        var outerRadius = !initial || initial && offsetMultiplier <= 1 && calcWithInnerRadius == false ? this.radius * offsetMultiplier : 0;
        var arc = d3.arc().outerRadius(outerRadius).innerRadius(innerRadius);

        if (subMethod) {
          return arc[subMethod](disPi);
        } else {
          return arc(disPi);
        }
      }
    }, {
      key: "radius",
      get: function get() {
        var dv = this.dv;
        var value = Math.min(dv.args('width') * .5, dv.args('height') * .5);

        if (dv.args("colorLegend")) {
          value -= value * .25;
        }

        if (dv.args("piLabelStyle") == 'linked') {
          value -= value * .25;
        }

        return value;
      }
    }]);

    return Pi;
  }(Component);

  var Tip = /*#__PURE__*/function (_Component) {
    _inherits(Tip, _Component);

    var _super = _createSuper(Tip);

    function Tip(dv, classToAdd) {
      _classCallCheck(this, Tip);

      return _super.call(this, dv, {
        classToAdd: classToAdd
      });
    }

    _createClass(Tip, [{
      key: "getCall",
      value: function getCall() {
        var tt = this;
        var dv = this.dv;
        return d3.tip().attr('class', "".concat(tt.classToAdd)).style('width', function () {
          if (typeof dv.args('tooltipWidth') === 'number') {
            return "".concat(dv.args('tooltipWidth'), "px");
          } else if (dv.args('tooltipWidth') == 'auto') {
            return dv.args('tooltipWidth');
          }
        }).style('text-align', dv.args('tooltipTextAlign')).direction(dv.args('tooltipDirectionParameter') || dv.args('tooltipDirection')).html(Tip.html);
      }
    }, {
      key: "show",
      value: function show() {}
    }, {
      key: "default",
      value: function _default(dis, i) {
        var dv = this.dv;
        var html = "<div class=\"".concat(dv.createClass('tooltip-data'), "\">");

        var _loop = function _loop(prop) {
          if (Object.prototype.hasOwnProperty.call(dis, prop)) {
            var propIsOutputted = false;

            if (_typeof(dis[prop]) !== 'object') {
              html += (_readOnlyError("html"), "<div class=\"".concat(dv.createClass('tooltip-data-property'), "\">")); // label

              if (dv.args('srcType') !== 'row') {
                html += (_readOnlyError("html"), "<strong class=\"".concat(dv.createClass('tooltip-data-property-label'), "\">").concat(prop, ":</strong> "));
              }

              DatumKeys.forEach(function (keyKey) {
                if (dv.args("key['".concat(keyKey, "']")) && dv.args("key['".concat(keyKey, "']")).lastIndexOf(prop) > -1 && dv.format(keyKey) && propIsOutputted == false) {
                  html += (_readOnlyError("html"), "<span class=\"".concat(dv.createClass('tooltip-data-property-content'), "\">").concat(dv.format(keyKey)(dv._get(dis, dv.args("key['".concat(keyKey, "' ]")))), " </span>"));
                  propIsOutputted = (_readOnlyError("propIsOutputted"), true);
                }
              });

              if (propIsOutputted == false) {
                // content
                html += (_readOnlyError("html"), "<span class=\"".concat(dv.createClass('tooltip-data-property-content'), "\">").concat(dis[prop], "</span>"));
              }

              html += (_readOnlyError("html"), '</div>');
            }
          }
        };

        for (var prop in dis) {
          _loop(prop);
        }

        html += (_readOnlyError("html"), '</div>');
        return html;
      }
    }, {
      key: "html",
      get: function get() {
        var dv = this.dv;
        return dv.args('tooltipContent') || Tip.default;
      }
    }]);

    return Tip;
  }(Component);

  /*!
  * 1point21 Data Vizualiser Version 1.2.1
  * Render Script
  * @license yes
  * DO NOT EDIT min.js
  * edit its corresponding unminified js file in /src instead
  */

  /* DO NOT TOUCH I DEV ON THIS BOI I ENQUEUE THE MINIFIED ONE ANYWAY  :< */

  /*

  TODO:
  pie does not display a wHOLE PIE
  duisplay types for multiple
  - compare
  - slider
  - overlap
  - one
  */

  /*****************************************************************************
   * ATTR ABD SHIT DEFINITIONS
  *****************************************************************************/

  var  //yeeee
  PREFIX = 'dv',
      BASE_TYPES = ['bar', 'pie', 'line', 'scatter'];
  var CLASS_READY = "".concat(PREFIX, "-initialized"),
      CLASS_ERROR = "".concat(PREFIX, "-fatality"),
      CLASS_HEADER = "".concat(PREFIX, "-heading"),
      CLASS_TITLE = "".concat(PREFIX, "-title"),
      CLASS_DESCRIPTION = "".concat(PREFIX, "-description"),
      CLASS_BODY = "".concat(PREFIX, "-body"),
      CLASS_SVG = "".concat(PREFIX, "-svg"),
      CLASS_G_CONTAINER = "".concat(PREFIX, "-container"),
      CLASS_LABELS = "".concat(PREFIX, "-labels"),
      CLASS_LABEL_PREFIX = "".concat(PREFIX, "-label"),
      CLASS_RULERS = "".concat(PREFIX, "-rulers"),
      CLASS_RULER_PREFIX = "".concat(PREFIX, "-rule"),
      CLASS_RULER_ALIGN_PREFIX = "".concat(CLASS_RULER_PREFIX, "-align"),
      CLASS_GRIDS = "".concat(PREFIX, "-grid"),
      CLASS_GRID_PREFIX = "".concat(CLASS_GRIDS, "-col"),
      CLASS_GRID_INC_PREFIX = "".concat(CLASS_GRID_PREFIX, "-increment"),
      CLASS_GRAPH = "".concat(PREFIX, "-graph"),
      CLASS_LINE_GRAPH = "".concat(PREFIX, "-line"),
      CLASS_ITEM = "".concat(CLASS_GRAPH, "-item"),
      CLASS_ITEM_BLOB = "".concat(CLASS_ITEM, "-shape"),
      CLASS_LINE_FILL = "".concat(CLASS_LINE_GRAPH, "-fill"),
      CLASS_TEXTS = "".concat(PREFIX, "-text"),
      CLASS_CURSOR_STALKER = "".concat(PREFIX, "-cursor-stalker"),
      CLASS_TOOLTIP = "".concat(PREFIX, "-tooltip"),
      OPTIMAL_DEFAULT_DATA_COUNT = 9,
      OPTIMAL_SCALE_LOG_CONST = 10;
  /*****************************************************************************
   * MAIN BITCH STARTS HERE
  *****************************************************************************/

  var _inpSet = new WeakMap();

  var _data = new WeakMap();

  var _is_debuggy = new WeakMap();

  var _renderAG = new WeakSet();

  var _parseData = new WeakSet();

  var _drawGraphSet = new WeakSet();

  var DataVisualizer = /*#__PURE__*/function () {
    function DataVisualizer(selector, settings) {
      _classCallCheck(this, DataVisualizer);

      _drawGraphSet.add(this);

      _parseData.add(this);

      _renderAG.add(this);

      _is_debuggy.set(this, {
        get: _get_is_debuggy,
        set: void 0
      });

      _inpSet.set(this, {
        writable: true,
        value: false
      });

      _data.set(this, {
        writable: true,
        value: {
          displayed: false,
          complete: false
        }
      });

      if (!window.d3) {
        return false;
      }

      var _dv = this;

      _dv.selector = selector;
      _dv.elem = document.querySelector(selector);

      if (VaildateBrowser()) {
        var error = document.createElement('div');
        error.className = "".concat(CLASS_BODY, " ").concat(CLASS_ERROR);
        error.innerHTML = 'Sorry, this graphic needs D3 to render the data but your browser does not support it.<br><br> Newer versions of Chrome, Edge, Firefox and Safari are recommended. <br><br>See <em><a target="_blank" rel="nofollow" href="https://d3-wiki.readthedocs.io/zh_CN/master/Home/#browser-platform-support">the official wiki</a></em> for more information';

        _dv.elem.appendChild(error);

        throw new Error('D3 not supported by browser');
      } // fallback + validate color data
      // if color data key aint set put in name


      if (!_dv._get(settings, 'key.color')) {
        settings.key.color = settings.key[0]; //if legend was not fucked with we take the authority to kill legend

        if (!settings.colorLegend) {
          settings.colorLegend = false;
        }
      }
      // if(!dv._get(settings,'key.area')){
      // 	settings.key.area
      // }

      _classPrivateFieldSet(_dv, _inpSet, settings);

      _dv.isLoaded = false;
      _dv.resizeInt = null;

      _dv.load();
    }

    _createClass(DataVisualizer, [{
      key: "UiEl",
      value: function UiEl(elem) {
        if (elem) {
          this._resetUiEl(elem);
        }

        return this.elem;
      }
    }, {
      key: "_resetUiEl",
      value: function _resetUiEl(elem) {
        if (elem) {
          this.elem = elem;
        } else {
          throw new Error('Needs a valid element to reset component UI root element');
        }
      }
      /*****************************************************************************
       * MAIN BITCH STARTS HERE
      *****************************************************************************/

    }, {
      key: "_get",
      value: function _get(obj, stringedKeys, isNum) {
        return _classStaticPrivateMethodGet(DataVisualizer, DataVisualizer, _deepGet).call(DataVisualizer, obj, stringedKeys, isNum);
      }
    }, {
      key: "_is_base",
      value: function _is_base(types) {
        var _this = this;

        var templates = [];

        if (typeof types === 'string') {
          templates.push(types);
        } else if (Array.isArray(types)) {
          types.forEach(function (type) {
            templates.push(type);
          });
        }

        var toReturn = false;
        templates.forEach(function (template) {
          if (_this.args('type').includes("".concat(template)) && !toReturn) {
            toReturn = true;
          }
        });
        return toReturn;
      }
    }, {
      key: "_has_grid",
      value: function _has_grid(axisName) {
        return this._has_ticks(axisName) && this._has_axis_prop('grid', axisName);
      }
    }, {
      key: "_has_labels",
      value: function _has_labels(axisName) {
        return this._has_ticks(axisName) && this._has_axis_prop('label', axisName);
      }
    }, {
      key: "_has_ticks",
      value: function _has_ticks(axisName) {
        return this._has_axis_prop('ticks', axisName);
      }
    }, {
      key: "_has_axis_prop",
      value: function _has_axis_prop(property, axisName) {
        if (property && !this._is_base('pie')) {
          if (axisName) {
            return this.args(Str.toCamelCase("".concat(axisName, " ").concat(property)));
          } else {
            return this.args(Str.toCamelCase("x ".concat(property))) || this.args(Str.toCamelCase("y ".concat(property)));
          }
        }
      }
    }, {
      key: "args",
      value: function args(key) {
        key = key || false;
        var settings = DeepValidate(DataVisualizer.defaults(), _classPrivateFieldGet(this, _inpSet));
        return key ? _classStaticPrivateMethodGet(DataVisualizer, DataVisualizer, _deepGet).call(DataVisualizer, settings, key) : settings;
      }
    }, {
      key: "outer",
      value: function outer(dimension) {
        var margins = [];

        if (dimension == 'width') {
          margins = ['left', 'right'];
        } else {
          margins = ['top', 'bottom'];
        }

        return this.args(dimension) + this.margin[margins[0]] + this.margin[margins[1]];
      }
    }, {
      key: "interpolate",
      value: function interpolate(start, end, fn, d3fn) {
        fn = fn || function (value, start, end) {
          return value;
        };

        d3fn = d3fn || 'interpolate';
        var i = d3[d3fn](start, end);
        return function (t) {
          var interVal = i(t);
          return fn(interVal, start, end);
        };
      }
    }, {
      key: "createClass",
      value: function createClass(classFallback, classForTrue, trueLogic, hasPrefix) {
        classFallback = classFallback || '';
        classForTrue = classForTrue || false;
        trueLogic = trueLogic != false || trueLogic == true;
        hasPrefix = hasPrefix != false || hasPrefix == true;
        return "".concat(hasPrefix ? "".concat(PREFIX, "-") : '').concat(trueLogic ? classForTrue : classFallback);
      }
    }, {
      key: "axisName",
      value: function axisName(keyKey) {
        var dv = this;

        if (keyKey == 0 || keyKey == 1) {
          return dv.args('xData') == keyKey ? 'x' : 'y';
        } else {
          return keyKey;
        }
      }
    }, {
      key: "range",
      value: function range(keyKey) {
        var dv = this;
        var axisName = dv.axisName(keyKey);
        var toReturn = [];

        switch (keyKey) {
          case 'color':
            toReturn = dv.args("".concat(keyKey, "Palette"));
            break;

          case 'area':
            toReturn = [dv.args('areaMin'), dv.args('areaMax')];
            break;

          case 0:
          case 1:
            if (dv.args("".concat(ToOppoAxis(axisName), "Align")) == 'top' || dv.args("".concat(ToOppoAxis(axisName), "Align")) == 'left') {
              toReturn = [0, dv.args(ToSide(axisName))];
            } else {
              toReturn = [dv.args(ToSide(axisName)), 0];
            }

            break;
        }

        return toReturn;
      }
    }, {
      key: "domain",
      value: function domain(keyKey) {
        var dv = this;
        var key = dv.args("key['".concat(keyKey, "']"));
        var toReturn = [];

        if (key) {
          // @TODO get deep into the anals of this for multiple data setup
          var dat = dv.theData(true);
          var axisName = dv.axisName(keyKey);

          var pushToDom = function pushToDom(d) {
            if (!toReturn.includes(dv._get(d, key))) {
              toReturn.push(dv._get(d, key));
            }
          };

          switch (keyKey) {
            case 'color':
              dat.forEach(function (dis) {
                pushToDom(dis);
              });
              break;

            case 'area':
            case 0:
            case 1:
              if (dv.args('nameIsNum') == true || keyKey == 1 || keyKey == 'area') {
                var min, max; //min

                if (dv.args("".concat(axisName, "Min")) !== null && keyKey !== 'area') {
                  min = dv.args("".concat(axisName, "Min"));
                } else {
                  min = d3.min(dat, function (dis) {
                    return dv._get(dis, key, true);
                  });
                } //max


                if (dv.args("".concat(axisName, "Max")) !== null && keyKey !== 'area') {
                  max = dv.args("".concat(axisName, "Max"));
                } else {
                  max = d3.max(dat, function (dis) {
                    return dv._get(dis, key, true);
                  });
                }

                toReturn = [min, max]; //if it a scatter plot we get nereast

                if (dv._is_base('scatter') && keyKey == 0) {
                  var newMin = GetNearest(min),
                      newMax = GetNearest(max);
                  toReturn = [newMin, newMax];
                }
              } else {
                //retains multiple instances
                toReturn = dat.map(function (dis) {
                  return dv._get(dis, key, false);
                }); //this dont

                dat.forEach(function (dis) {
                  pushToDom(dis);
                });
              }

              if (dv.args("reverse.".concat(keyKey))) {
                // dont use .reverse because it's a piece of shit
                var reversed = [];

                for (var i = toReturn.length - 1; i >= 0; i--) {
                  reversed.push(toReturn[i]);
                }

                toReturn = reversed;
              }

              break;
          }
        }

        return toReturn;
      }
    }, {
      key: "scale",
      value: function scale(keyKey, dataToScale) {
        dataToScale = dataToScale || false;
        var dv = this;
        var toReturn;
        var range = dv.range(keyKey);
        var domain = dv.domain(keyKey);

        switch (keyKey) {
          case 'color':
            toReturn = d3.scaleOrdinal().range(range);
            break;

          case 'area':
          case 0:
          case 1:
            if (dv.args('nameIsNum') == true || keyKey == 1 || keyKey == 'area') {
              if (dv.args('nameIsNum') == true && keyKey == 0 && dv._is_base('scatter')) {
                toReturn = d3.scaleSymlog().constant(OPTIMAL_SCALE_LOG_CONST).range(range).domain(domain);
              } else {
                toReturn = d3.scaleLinear().range(range).domain(domain);
              }
            } else {
              if (dv._is_base(['line', 'scatter'])) {
                toReturn = d3.scalePoint() //scales shit to dimensios
                .range(range) // scaled data from available space
                .domain(domain);
              } else {
                toReturn = d3.scaleBand() //scales shit to dimensios
                .range(range) // scaled data from available space
                .domain(domain).paddingInner(dv.args('barGutter')) //spacing between
                .paddingOuter(dv.args('barGutter'));
              }
            }

            break;
        }

        return dataToScale ? toReturn(dataToScale) : toReturn;
      }
    }, {
      key: "format",
      value: function format(keyKey) {
        keyKey = Str.toCapitalize(keyKey.toString());
        var dv = this;
        var toReturn;

        if (typeof dv.args("format".concat(keyKey, "Parameter")) === 'function') {
          toReturn = dv.args("format".concat(keyKey, "Parameter"));
        } else if (typeof dv.args("format".concat(keyKey, "Parameter")) === 'string') {
          toReturn = function toReturn(value, i) {
            return d3.format(args("format".concat(keyKey, "Parameter")))(value);
          };
        } else {
          toReturn = function toReturn(value, i) {
            var divider = dv.args("format".concat(keyKey, "Divider")),
                prepend = dv.args("format".concat(keyKey, "Prepend")),
                append = dv.args("format".concat(keyKey, "Append")),
                dataPossiblyDivided = keyKey == 1 || dv.args('nameIsNum') == true ? value / divider : value,
                formatted = "".concat(prepend).concat(dataPossiblyDivided).concat(append);
            return formatted;
          };
        }

        return toReturn;
      }
    }, {
      key: "Axis",
      value: function Axis$1(axisName) {
        return new Axis(this, axisName);
      }
    }, {
      key: "Shape",
      value: function Shape$1(dis, i) {
        dis = dis || false;
        i = i || null;
        return new Shape(this, dis, i);
      }
    }, {
      key: "Pi",
      value: function Pi$1(dis, i) {
        dis = dis || false;
        i = i || null;
        return new Pi(this, dis, i);
      }
    }, {
      key: "Line",
      value: function Line$1(data) {
        data = data || false;
        return new Line(this, data);
      }
    }, {
      key: "Label",
      value: function Label$1(axisName) {
        return new Label(this, axisName);
      }
    }, {
      key: "theData",
      value: function theData(displayed, d3method) {
        displayed = displayed || false;
        d3method = d3method || ''; //group,pie

        var dv = this;
        var toReturn = [];
        var data = displayed ? dv.drawnData : dv.completeData;

        switch (d3method) {
          case 'pie':
            var pie = d3[d3method]().sort(null).value(function (dis) {
              return dv._get(dis, dv.args("key[1]"), true);
            });
            toReturn = pie(data);
            break;

          case 'group':
            if (dv.args('srcMultiple') == true) {
              toReturn = d3[d3method](data, function (dis) {
                return dis[dv.args("key['multiple']")];
              }); //to array because its easier to deal with

              toReturn = Array.from(toReturn, function (_ref) {
                var _ref2 = _slicedToArray(_ref, 2),
                    name = _ref2[0],
                    value = _ref2[1];

                return {
                  parent: name,
                  values: value
                };
              });
              break;
            }

          default:
            toReturn = data;
        }

        return toReturn;
      }
    }, {
      key: "kill",
      value: function kill(errorMessage) {
        var dv = this;
        var errorFront = "Sorry, unable to display data." + (_classPrivateFieldGet(dv, _is_debuggy) ? "<br> Please check the console for more details" : '');
        dv.theUi.classed("".concat(CLASS_READY), true);

        if (!dv.theUi.select(".".concat(CLASS_BODY, ".").concat(CLASS_ERROR))) {
          dv.theUi.append('div').attr('class', "".concat(CLASS_BODY, " ").concat(CLASS_ERROR)).html(errorFront);
        }

        console.error(errorMessage);
        return false;
      }
    }, {
      key: "renderHeader",
      value: function renderHeader() {
        var dv = this;
        dv.theUi.append('div').lower().attr('class', "".concat(CLASS_HEADER));

        if (dv.args('title')) {
          dv.header.append('span').attr('class', "".concat(CLASS_TITLE)).text(dv.args('title'));
        }

        if (dv.args('description')) {
          dv.header.append('span').attr('class', "".concat(CLASS_DESCRIPTION)).text(dv.args('description'));
        }

        dv.header.style('padding-top', function () {
          "".concat(dv.margin.top / dv.args('height') * 50, "%");
        }).style('padding-left', function () {
          "".concat(dv.margin.left / dv.outer('width') * 100, "%");
        }).style('padding-right', function () {
          "".concat(dv.margin.right / dv.outer('width') * 100, "%");
        }).transition(dv.duration).styleTween('opacity', function () {
          dv.interpolate(0, 1);
        });
      }
    }, {
      key: "renderContent",
      value: function renderContent() {
        var dv = this;
        dv.theUi.append('div').attr('class', "".concat(CLASS_BODY)).style('position', 'relative').style('padding-bottom', function () {
          return "".concat(dv.outer('height') / dv.outer('width') * 100, "%");
        }).style('position', 'relative'); //render the rest l8er so it dont get in the way of performance

        dv.addListeners(dv);
      }
    }, {
      key: "renderSVG",
      value: function renderSVG() {
        var dv = this;
        dv.content.append('svg').attr('class', "".concat(CLASS_SVG, "\n\t\t\t\t").concat(dv.createClass('type'), "-").concat(dv.args('type'), "\n\t\t\t\t").concat(dv.createClass('base'), "-").concat(dv.baseType, "\n\t\t\t\t").concat(dv.createClass('no', 'has', dv.args('colorPalette').length > 0 || dv.args('linePointsColor') !== null || dv.args('lineColor') !== null), "-palette\n\n\t\t\t\t").concat(dv.createClass('no', 'has', !dv._is_base('pie') && (dv.args('xTicks') || dv.args('yTicks'))), "-palette\n\n\t\t\t\t").concat(dv.createClass('no', 'has', dv.args('colorLegend')), "-legend\n\n\t\t\t\t").concat(dv.createClass("no-label", "pi-label-style-".concat(dv.args('piLabelStyle')), dv.args('colorLegend') && dv.args('piLabelStyle') !== null), "\n\t\t\t"));
        dv.svg.attr('id', "".concat(this.selector, "-svg")).style('position', 'absolute').style('top', '0').style('left', '0').style('bottom', '0').style('right', '0').style('margin', 'auto').attr('version', '1.1').attr('x', '0px').attr('y', '0px').attr('viewBox', "0 0 ".concat(dv.outer('width'), " ").concat(dv.outer('height'))).attr('preserveAspectRatio', 'xMidYMid meet').attr('xml:space', 'preserve').attr('width', dv.outer('width')).attr('height', dv.outer('height')); //container for bitches

        dv.svg.append('g').attr('class', CLASS_G_CONTAINER).attr('font-size', dv.args('fontSize')).style('line-height', 1).attr('transform', "translate( ".concat(dv.margin.left, " , ").concat(dv.margin.top, " )"));
        dv._has_labels && dv.renderLabels();

        if (dv._has_ticks()) {
          dv.renderRulers();
          dv._has_grid && dv.renderGrid();
        }

        dv.logStyleWarns();
        dv.draw();
      }
    }, {
      key: "renderLabels",
      value: function renderLabels() {
        var dv = this;

        _classPrivateMethodGet(dv, _renderAG, _renderAG2).call(dv, CLASS_LABELS);

        Coordinates.forEach(function (axisName) {
          if (dv._has_ticks(axisName)) {
            dv.labels.append('text').attr('class', "".concat(CLASS_LABEL_PREFIX, "-").concat(axisName)).attr('y', function () {
              return dv.Label(axisName).offset('y');
            }).attr('x', function () {
              return dv.Label(axisName).offset('x');
            }).attr('font-size', '1em').attr('text-anchor', 'middle').attr('fill', 'currentColor').attr('opacity', 0).text(dv.args(axisName + 'Label')).attr('transform', function () {
              if (axisName == 'y') {
                return 'rotate(-90)';
              }
            }).transition(dv.duration).attr('opacity', 1);
          }
        });
      }
    }, {
      key: "renderTicks",
      value: function renderTicks(tickContainer, isGrid) {
        isGrid = isGrid || false;

        if (!tickContainer) {
          return;
        }

        var dv = this;
        Coordinates.forEach(function (axisName) {
          if (dv._has_ticks(axisName)) {
            var alignString = dv.args("".concat(axisName, "Align")); //ruler/grid

            tickContainer.append('g').attr('class', "\n\t\t\t\t\t\t\t".concat(dv.createClass("".concat(CLASS_RULER_PREFIX, "-").concat(axisName), "".concat(CLASS_GRID_PREFIX, "-").concat(axisName), isGrid, false), "\n\t\t\t\t\t\t\t").concat(dv.createClass("".concat(CLASS_RULER_ALIGN_PREFIX, "-").concat(alignString), "".concat(CLASS_GRID_INC_PREFIX, "-").concat(dv.args("".concat(axisName, "GridIncrement"))), isGrid, false), "\n\t\t\t\t\t\t")).attr('transform', function () {
              var transformCoord;

              switch (axisName + ' ' + alignString) {
                case 'x bottom':
                  transformCoord = "0 , ".concat(dv.args('height'));
                  break;

                case 'y right':
                  transformCoord = "".concat(dv.args('width'), " , 0");
                  break;

                default:
                  transformCoord = '0 , 0';
              }

              if (transformCoord) return 'translate(' + transformCoord + ')';
            });
          }
        });
      }
    }, {
      key: "renderRulers",
      value: function renderRulers() {
        var dv = this;

        _classPrivateMethodGet(dv, _renderAG, _renderAG2).call(dv, CLASS_RULERS);

        dv.rulers.attr('font-size', dv.args('textTicksSize') + 'em');
        dv.renderTicks(dv.rulers, false);
      }
    }, {
      key: "renderGrid",
      value: function renderGrid() {
        var dv = this;

        _classPrivateMethodGet(dv, _renderAG, _renderAG2).call(dv, CLASS_GRIDS);

        dv.grid.attr('font-size', dv.args('textTicksSize') + 'em');
        dv.renderTicks(dv.grid, true);
      }
    }, {
      key: "drawTooltip",
      value: function drawTooltip() {
        var dv = this;
        dv.svg.append('circle').attr('class', "".concat(CLASS_CURSOR_STALKER));
        dv.svg.call(dv.Tip.getCall());
      }
    }, {
      key: "logStyleWarns",
      value: function logStyleWarns() {
        var dv = this;

        if (_classPrivateFieldGet(dv, _is_debuggy)) {
          if (dv.args('width') == DataVisualizer.defaults('width') && dv.args('height') == DataVisualizer.defaults('height') && dv.completeData > OPTIMAL_DEFAULT_DATA_COUNT) {
            console.debug(dv.selector + ' Width and height was not adjusted. graph elements may not fit in the canvas');
          } else if (dv.args('width') < DataVisualizer.defaults('width') && dv.args('height') < DataVisualizer.defaults('height')) {
            console.debug(dv.selector + ' set canvas width and or height may be too small.\n Tip: The given height and width are not absolute and act more like aspect ratios. svgs are responsive and will shrink along with content.');
          }

          if (JSON.stringify(dv.args('margin')) == JSON.stringify(DataVisualizer.defaults('margin')) && dv._has_labels() && dv._has_ticks()) {
            console.debug(dv.selector + ' text may overlap. margins may need to be modified');
          }
        }
      }
    }, {
      key: "drawAxes",
      value: function drawAxes() {
        var dv = this;
        Coordinates.forEach(function (axisName) {
          if (dv._has_ticks(axisName)) {
            dv.ruler(axisName).transition(dv.duration).call(dv.Axis(axisName).getCall(false)).attr('font-family', null).attr('font-size', null);

            if (dv._has_grid(axisName)) {
              dv.gridCol(axisName).transition(dv.duration).call(dv.Axis(axisName).getCall(true));
              dv.gridCol(axisName).selectAll('g').classed('grid', true).filter(function (dis, i) {
                //IM HERE FUCKER
                var isAligned = false;
                dv.ruler(axisName).selectAll('g').each(function (tik) {
                  //if current looped tik matches dis grid data, add the class boi
                  if (tik == dis) {
                    isAligned = true;
                  }
                });
                return isAligned;
              }).classed('tick-aligned', true);
            }
          }
        });
      }
    }, {
      key: "drawGraph",
      value: function drawGraph() {
        _classPrivateMethodGet(this, _drawGraphSet, _drawGraphSet2).call(this, CLASS_GRAPH);
      }
    }, {
      key: "drawText",
      value: function drawText() {
        _classPrivateMethodGet(this, _drawGraphSet, _drawGraphSet2).call(this, CLASS_TEXTS);
      }
    }, {
      key: "readyData",
      value: function readyData() {
        var dv = this;
        var toReturn;

        if (dv._has_nested_data) {
          toReturn = dv.theData(true, 'group');
        } else {
          //fake it so it still wiorks
          toReturn = [{
            parent: 'flat',
            values: dv.theData(true)
          }];
        }

        return toReturn;
      }
    }, {
      key: "drawLineGraph",
      value: function drawLineGraph() {
        var dv = this;
        dv.graphs.append('path').lower().attr('class', "".concat(CLASS_LINE_GRAPH, "\n\t\t\t\t").concat(dv.createClass('no', 'has', dv.args('lineColor') !== null), "-color")).attr('fill', 'none').attr('stroke-width', dv.args('lineWeight')).attr('stroke-linejoin', 'round').attr('stroke-dasharray', dv.args('lineDash')).attr('stroke-opacity', 1).attr('stroke-dasharray', '0,0').attr('stroke', dv.args("lineColor")) // .attr('d',getLinePath(false,false))
        .transition(dv.duration).attrTween('d', function (dat) {
          return dv.interpolate(dv.Line(dat.values).path(false, true), dv.Line(dat.values).path(false, false));
        });

        if (dv.args('lineFill')) {
          dv.graphs.append('path').lower().attr('class', "".concat(CLASS_LINE_FILL, "\n\t\t\t\t\t").concat(dv.createClass('no', 'has', dv.args("lineFillColor") !== null || dv.args("lineColor") !== null), "-color")).attr('fill', dv.args("lineFillColor") || dv.args("lineColor")).attr('fill-opacity', dv.args("lineFillOpacity")).transition(dv.duration).attrTween('d', function (dat) {
            return dv.interpolate(dv.Line(dat.values).path(true, true), dv.Line(dat.values).path(true, false));
          });
        }
      }
    }, {
      key: "drawItemShapes",
      value: function drawItemShapes() {
        var dv = this;
        var shape = dv.itemShapes.data(function (d) {
          return d.values;
        });
        shape.exit().transition(dv.duration).style('opacity', 0).remove();
        var shape_enter = shape.enter().append(dv.Shape().tag).attr('class', function (dis) {
          return "".concat(CLASS_ITEM, "\n\t\t\t\t\t").concat(CLASS_ITEM_BLOB, "\n\t\t\t\t\tdata-name-").concat(dv._get(dis, dv.args("key[0]")), "\n\t\t\t\t\t");
        }); //COORDINATE

        if (dv._is_base(['bar', 'line', 'scatter'])) {
          shape_enter.attr(dv.Shape().coordAttr('x'), function (dis, i) {
            return dv.Shape(dis, i).offset('x', true);
          }).attr(dv.Shape().coordAttr('y'), function (dis, i) {
            return dv.Shape(dis, i).offset('y', true);
          });
        } //SIZE N SHIT


        if (dv._is_base(['line', 'scatter'])) {
          shape_enter.attr('r', function (dis, i) {
            return dv.Shape(dis, i).radius(true);
          });
        } else if (dv._is_base('bar')) {
          shape_enter.attr('width', function (dis, i) {
            return dv.Shape(dis, i).size('x', true);
          }).attr('height', function (dis, i) {
            return dv.Shape(dis, i).size('y', true);
          });
        } //FILL AND STROKE
        // render but not visible so that tooltip can work if needed


        if (dv._is_base('line') && !dv.args('linePoints')) {
          shape_enter.attr('opacity', 0);
        }

        var shape_merge = shape.merge(shape_enter); //COORDINATES

        if (dv._is_base(['bar', 'line', 'scatter'])) {
          shape_merge // .transition(dv.duration)
          .attr(dv.Shape().coordAttr('x'), function (dis, i) {
            return dv.Shape(dis, i).offset('x');
          }).attr(dv.Shape().coordAttr('y'), function (dis, i) {
            console.log('luh', dv.Shape(dis, i).offset('y', false));
            return dv.Shape(dis, i).offset('y');
          });
        } //SIZE N SHIT


        if (dv._is_base(['line', 'scatter'])) {
          shape_merge.transition(dv.duration).attr('r', function (dis, i) {
            return dv.Shape(dis, i).radius();
          });
        } else if (dv._is_base('bar')) {
          shape_merge.transition(dv.duration).attr('width', function (dis, i) {
            return dv.Shape(dis, i).size('x');
          }).attr('height', function (dis, i) {
            return dv.Shape(dis, i).size('y');
          });
        } //PETH


        if (dv._is_base('pie')) {
          shape_merge.transition(dv.args("transition")) //DO NOT
          .attrTween('d', function (dis, i) {
            dis.pie = dis.pie || dv.theData(true, 'pie')[i];
            var currPie = dis.pie;
            return dv.interpolate(currPie.endAngle, currPie.startAngle, function (value) {
              currPie.startAngle = value;
              return dv.Pi(dis, i).path(true);
            });
          });
        } //tooltip


        if (dv.args("tooltipEnable")) ; //line  colors


        if (!dv.args("colorPalette").length) {
          if (dv._is_base('line') && (dv.args("linePointsColor") || dv.args("lineColor"))) {
            shape_merge.attr('fill', function () {
              return dv.args("linePointsColor") || dv.args("lineColor");
            });
          }
        } else {
          shape_merge.attr('fill', function (dis, i) {
            return dv.scale("color", dv._get(dis, "key.color"));
          });

          if (dv._is_base('scatter')) {
            shape_merge.attr('fill-opacity', args.areaOpacity).attr('stroke-width', 1).attr('stroke', function (dis, i) {
              return dv.scale(dv._get(dis, "key.color"));
            });
          }
        }
      }
    }, {
      key: "drawItemStamps",
      value: function drawItemStamps() {
        var dv = this;
        dv._has_polyline && dv.drawItemPolyline();
      }
    }, {
      key: "drawItemPolyline",
      value: function drawItemPolyline() {}
    }, {
      key: "drawLegend",
      value: function drawLegend() {}
    }, {
      key: "draw",
      value: function draw(data) {
        var dv = this;
        data = data || dv.drawnData;
        dv.drawnData = data; // ok do the thing now

        _classPrivateFieldGet(dv, _is_debuggy) && console.info("\n", dv.selector, '(' + dv.args('title') + ')', '-------------------------------------------------------------------', "\n", 'calculated shit', dv, "\n", 'data', _classPrivateFieldGet(dv, _data), "\n", 'args', dv.args(), "\n", "\n");
        /******** AXIS + GRID ********/

        if (dv._is_base(['bar', 'line', 'scatter'])) {
          dv._has_ticks && dv.drawAxes();
        }
        /******** GRAP ********/


        dv.drawGraph();
        /******** TEK ********/

        dv.drawText();
        /******** LINE ********/

        if (dv._is_base('line')) {
          dv.drawLineGraph();
        }
        /******** BLOBS ********/


        dv.drawItemShapes();
        /******** ITEM LABELS ********/

        dv._has_text && dv.drawItemStamps();
        /******** LEGEND ********/

        dv.args('colorLegend') && dv.drawLegend();
      }
    }, {
      key: "label",
      value: function label(axis) {
        if (axis) {
          return this.labels.select(".".concat(CLASS_LABEL_PREFIX, "-").concat(axis));
        } else {
          return this.labels();
        }
      }
    }, {
      key: "ruler",
      value: function ruler(axis) {
        if (axis) {
          return this.rulers.select(".".concat(CLASS_RULER_PREFIX, "-").concat(axis));
        } else {
          return this.rulers();
        }
      }
    }, {
      key: "gridCol",
      value: function gridCol(axis) {
        if (axis) {
          return this.grid.select(".".concat(CLASS_GRID_PREFIX, "-").concat(axis));
        } else {
          return this.grid;
        }
      }
    }, {
      key: "load",
      value: function load() {
        var dv = this; // data is embedded on the page oooooo

        if (dv.args('srcPath').indexOf(window.location.href) > -1) {
          var jsonSelector = document.getElementById(Str.hash(dv.args('srcPath'))).innerHTML;

          if (Str.isValidJSONString(jsonSelector)) {
            var dataIsJSON = JSON.parse(jsonSelector);
            dv.init(dataIsJSON);
          } else {
            dv.kill('Data input may not be valid. Please check and update the syntax');
          } //o its not ok we normal now

        } else {
          switch (Str.fileExtension(dv.args('srcPath'))) {
            case 'csv':
            case 'dsv':
            case 'tsv':
            case 'xml':
              d3[Str.fileExtension(dv.args('srcPath'))](dv.args('srcPath'), function (d) {
                return d;
              }).then(function (retrievedData) {
                dv.init(retrievedData);
              }).catch(function (error) {
                dv.kill(error);
              });
              break;

            default:
              d3.json(dv.args('srcPath'), function (d) {
                return d;
              }).then(function (retrievedData) {
                dv.init(retrievedData);
              }).catch(function (error) {
                dv.kill(error);
              });
              break;
          }
        }
      }
    }, {
      key: "init",
      value: function init(retrievedData) {
        var dv = this;
        dv.theUi.classed("".concat(CLASS_READY, "\n\t\t\t\t").concat(dv.createClass('', 'dark', ColorIsDark(dv.args('colorBackground')))), true).style('background-color', dv.args('colorBackground')); //set data

        dv.completeData = _classPrivateMethodGet(dv, _parseData, _parseData2).call(dv, retrievedData);
        dv.renderHeader();
        dv.renderContent();
      }
    }, {
      key: "addListeners",
      value: function addListeners(dv) {
        dv = dv || this;
        window.addEventListener('scroll', dv.handlerScroll);
        window.addEventListener('resize', dv.handlerResize);
      }
    }, {
      key: "_has_nested_data",
      get: function get() {
        return !(this.args('srcMultiple') && this._is_base('pie'));
      }
    }, {
      key: "_name_is_num",
      get: function get() {
        return this.args('nameIsNum');
      }
    }, {
      key: "_has_text",
      get: function get() {
        if (!this.args('toolTip') && (this._is_base(['bar', 'line']) && (!this.args('xTicks') || !this.args('yTicks')) || this._is_base('pie') && (this.args('piLabelStyle') || !this.args('colorLegend')))) {
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: "_has_both_text",
      get: function get() {
        if (this._has_text && (this._is_base(['bar', 'line', 'scatter']) && !this.args('xTicks') && !this.args('yTicks') || this._is_base('pie') && !this.args('colorLegend') && this.args('piLabelStyle') !== null)) {
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: "_has_polyline",
      get: function get() {
        return this._is_base('pie') && this.args('piLabelStyle') == 'linked';
      }
    }, {
      key: "_has_tooltip",
      get: function get() {
        return this.args('tooltipEnable');
      }
    }, {
      key: "drawnData",
      get: function get() {
        return _classPrivateFieldGet(this, _data).displayed.length ? _classPrivateFieldGet(this, _data).displayed : _classPrivateFieldGet(this, _data).complete;
      },
      set: function set(data) {
        _classPrivateFieldGet(this, _data).displayed = data;
      }
    }, {
      key: "completeData",
      get: function get() {
        return _classPrivateFieldGet(this, _data).complete;
      },
      set: function set(data) {
        _classPrivateFieldGet(this, _data).complete = data;
      }
    }, {
      key: "baseType",
      get: function get() {
        var dv = this;
        var toReturn;
        BASE_TYPES.forEach(function (type) {
          if (dv._is_base(type) && !toReturn) {
            toReturn = type;
          }
        });
        return toReturn;
      }
    }, {
      key: "fontSize",
      get: function get() {
        return parseFloat(this.args('fontSize'));
      }
    }, {
      key: "legendSize",
      get: function get() {
        return this.args('textLegendSize') * this.fontSize * 2;
      }
    }, {
      key: "margin",
      get: function get() {
        var dv = this;
        return {
          top: ValidMargin(dv.args('margin[0]')) || ValidMargin(dv.args('margin')) || 0,
          right: ValidMargin(dv.args('margin[1]')) || ValidMargin(dv.args('margin[0]')) || ValidMargin(dv.args('margin')) || 0,
          bottom: ValidMargin(dv.args('margin[2]')) || ValidMargin(dv.args('margin[0]')) || ValidMargin(dv.args('margin')) || 0,
          left: ValidMargin(dv.args('margin[3]')) || ValidMargin(dv.args('margin[1]')) || ValidMargin(dv.args('margin[0]')) || ValidMargin(dv.args('margin')) || 0
        };
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.outer('width');
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.outer('height');
      }
    }, {
      key: "duration",
      get: function get() {
        if (!this.__trans) {
          this.__trans = d3.transition().duration(this.args('transition')).ease(d3.easeLinear);
        }

        return this.__trans;
      }
    }, {
      key: "Tip",
      get: function get() {
        return new Tip(this, CLASS_TOOLTIP);
      }
    }, {
      key: "theUi",
      get: function get() {
        return d3.select(this.selector);
      }
    }, {
      key: "header",
      get: function get() {
        return this.theUi.select(".".concat(CLASS_HEADER));
      }
    }, {
      key: "content",
      get: function get() {
        return this.theUi.select(".".concat(CLASS_BODY));
      }
    }, {
      key: "svg",
      get: function get() {
        return this.content.select(".".concat(CLASS_SVG));
      }
    }, {
      key: "g",
      get: function get() {
        return this.svg.select(".".concat(CLASS_G_CONTAINER));
      }
    }, {
      key: "labels",
      get: function get() {
        return this.g.select(".".concat(CLASS_LABELS));
      }
    }, {
      key: "rulers",
      get: function get() {
        return this.g.select(".".concat(CLASS_RULERS));
      }
    }, {
      key: "grid",
      get: function get() {
        return this.g.select(".".concat(CLASS_GRIDS));
      }
    }, {
      key: "graphs",
      get: function get() {
        return this.g.selectAll(".".concat(CLASS_GRAPH));
      }
    }, {
      key: "line",
      get: function get() {
        return this.graphs.select(".".concat(CLASS_LINE_GRAPH));
      }
    }, {
      key: "lineFill",
      get: function get() {
        return this.graphs.select(".".concat(CLASS_LINE_FILL));
      }
    }, {
      key: "itemShapes",
      get: function get() {
        return this.graphs.selectAll(".".concat(CLASS_ITEM_BLOB));
      }
    }, {
      key: "texts",
      get: function get() {
        return this.g.select(".".concat(CLASS_TEXTS));
      }
    }, {
      key: "itemStamps",
      get: function get() {
        return this.texts.selectAll(".".concat(CLASS_ITEM_TEXT));
      }
    }, {
      key: "cursorStalker",
      get: function get() {
        return this.svg.select(".".concat(CLASS_CURSOR_STALKER));
      }
    }, {
      key: "tooltip",
      get: function get() {
        return this.theUi.select(".".concat(CLASS_TOOLTIP));
      }
    }, {
      key: "handlerScroll",
      get: function get() {
        var dv = this;
        return function (e) {
          var graphPosition = dv.elem.getBoundingClientRect().top;

          if (graphPosition < window.innerHeight * .5 && !dv.isLoaded) {
            dv.isLoaded = true;
            setTimeout(function () {
              dv.renderSVG();
              dv._has_tooltip && dv.drawTooltip();
            }, dv.args('delay'));
          }
        };
      }
    }, {
      key: "handlerResize",
      get: function get() {
        var dv = this;
        return function (e) {
          clearTimeout(dv.resizeInt);
          dv.resizeInt = setTimeout(function () {
            dv.draw();
          }, 300);
        };
      }
    }], [{
      key: "defaults",
      value: function defaults(key) {
        key = key || false;
        var settings = {
          //settings
          width: 600,
          height: 600,
          margin: 40,
          transition: 500,
          delay: 250,
          fontSize: '16px',
          // content
          title: '',
          description: '',
          //src
          srcType: '',
          srcPath: '',
          srcKey: null,
          srcMultiple: false,
          srcPreNest: false,
          //text
          textNameSize: .75,
          textValueSize: 1.25,
          textTicksSize: .75,
          textLegendSize: .75,
          // fields
          type: 'bar',
          nameIsNum: false,
          //keys
          key: {
            multiple: '_parent',
            0: 0,
            1: 1,
            color: null,
            area: null
          },
          //reverse
          reverse: {
            0: false,
            1: false,
            color: false,
            multiple: false,
            area: false
          },
          //format
          // name
          format0Prepend: '',
          format0Append: '',
          format0Parameter: null,
          format0Divider: 1,
          //@TODO deprecate
          // value
          format1Prepend: '',
          format1Append: '',
          format1Parameter: null,
          format1Divider: 1,
          //@TODO deprecate
          // color
          formatColorPrepend: '',
          formatColorAppend: '',
          formatColorParameter: null,
          //scatterplot area
          areaMin: 10,
          areaMax: 20,
          areaOpacity: .8,
          //kulay
          colorBackground: '#eee',
          colorPalette: [],
          colorData: null,
          colorLegend: false,
          //x settings
          xData: 0,
          xAlign: 'bottom',
          xTicks: false,
          xLabel: null,
          xTicksAmount: null,
          xParameter: null,
          xMin: null,
          xMax: null,
          xGrid: false,
          xGridIncrement: 1,
          xPrepend: '',
          xAppend: '',
          xDivider: 1,
          //y settings
          yData: 1,
          yAlign: 'left',
          yTicks: false,
          yLabel: null,
          yTicksAmount: null,
          yParameter: null,
          yMin: null,
          yMax: null,
          yGrid: false,
          yGridIncrement: 1,
          yPrepend: '',
          yAppend: '',
          yDivider: 1,
          //bar
          barTextWithin: false,
          barGutter: .1,
          //line
          lineStyle: '',
          lineWeight: 1,
          lineColor: null,
          linePoints: false,
          lineFill: false,
          linePointsColor: null,
          linePointsSize: null,
          lineFillColor: null,
          lineFillInvert: false,
          lineFillOpacity: .5,
          lineDash: [100, 0],
          //pi
          piLabelStyle: 'within',
          piInRadius: 0,
          //tooltip
          tooltipEnable: false,
          tooltipTextAlign: 'left',
          tooltipWidth: 'auto',
          tooltipDirection: 'n',
          tooltipDirectionParameter: null,
          tooltipContent: null,
          //2.0.0 new this.args. not implemented yet
          // multiple
          multipleDisplay: 'overlay',
          // single,versus,overlap
          //kulay
          colorBy: 'key',
          //set will influence key.color
          //advanced
          colorScheme: null
        };
        return key ? _classStaticPrivateMethodGet(DataVisualizer, DataVisualizer, _deepGet).call(DataVisualizer, settings, key) : settings;
      }
    }]);

    return DataVisualizer;
  }();

  var _deepGet = function _deepGet(obj, stringedKeys, isNum) {
    isNum = isNum || false;

    if (!stringedKeys) {
      return;
    }

    var splitString = stringedKeys.toString().replace(/('|"|\s|\t|\n|\r)/g, '') //quotes and spaces
    .replace(/\[(.+?)\]/, '.$1') //brackets
    .split('.') //split
    ; //remove mt

    splitString.forEach(function (key, i) {
      key == '' && splitString.splice(i, 1);
    });

    var multiIndex = function multiIndex(obj, is) {
      var toReturn = null; // console.warn('init multi',obj,is,typeof obj);

      if (is.length > 0 && _typeof(obj) === 'object') {
        //if it gooes 0 u ded
        toReturn = multiIndex(obj[is[0]], is.slice(1));
      } else {
        toReturn = isNum == true ? parseFloat(obj) : obj;
      }

      return toReturn;
    },
        value = multiIndex(obj, splitString);

    if (isNum == true && isNaN(value)) {
      console.warn("data with the key source of '".concat(stringedKeys, "' was passed as numeric but is not."));
    } // console.log(`%c final value to return from ${stringedKeys}: \n${value}`,"color: pink; font-family:sans-serif; font-size: 9px");


    return value;
  };

  var _get_is_debuggy = function _get_is_debuggy() {
    return document.body.classList.contains('logged-in');
  };

  var _renderAG2 = function _renderAG2(classToAdd) {
    var dv = this;
    dv.g.append('g').attr('class', classToAdd);
  };

  var _parseData2 = function _parseData2(dataToParse) {
    var dv = this; // heck if src key exists

    var toReturn;

    if (dv.args('srcKey')) {
      if (dv._get(dataToParse, dv.args('srcKey'))) {
        toReturn = dv._get(dataToParse, dv.args('srcKey'));
      } else {
        renderError("".concat(dv.selector, " provided source key is invalid"));
      }
    } else {
      toReturn = dataToParse;
    } // convert to single level for easy AAAAAAAAA-ing


    if (dv.args('srcMultiple') == true && dv.args('srcPreNest')) {
      var arrPreNest = [],
          appendParentProp = function appendParentProp(parentKey) {
        //add parent key to proops
        toReturn[parentKey].forEach(function (dis, i) {
          toReturn[parentKey][i]._parent = parentKey;
          arrPreNest.push(toReturn[parentKey][i]);
        });
      }; //if they are array


      if (Object.prototype.toString.call(toReturn) === '[object Array]') {
        toReturn.forEach(function (par, key) {
          appendParentProp(key);
        }); //if they are kwan have keys
      } else {
        Object.keys(toReturn).forEach(function (key) {
          //add parent key to proops
          appendParentProp(key);
        });
      }

      toReturn = arrPreNest;
    } //filter data that has null value


    toReturn = toReturn.filter(function (dis, i) {
      var toInclude = true;
      DatumKeys$1.forEach(function (keyKey) {
        var setKey = dv.args("key['".concat(keyKey, "']"));

        if (setKey && dv._get(dis, setKey) == null) {
          toInclude = false;

          if (_classPrivateFieldGet(dv, _is_debuggy)) {
            var humanForKey = keyKey == 0 ? 'name' : keyKey == 1 ? 'value' : keyKey;
            console.warn("".concat(dv.selector, " datum index '").concat(i, "' was filtered.\ndatum does not have data for the key '").concat(setKey, "', which is set as the property for '").concat(humanForKey, "'"));
          }
        }
      });

      if (toInclude) {
        return dis;
      }
    }); //sort data 0 so that it doesnt go forward then backward then forward on the graph which is weird

    if (dv.args('nameIsNum') == true) {
      var sortable = [];

      for (var i = 0; i < toReturn.length; i++) {
        if (toReturn[i]) {
          sortable.push(toReturn[i]);
        }
      }

      sortable.sort(function (a, b) {
        return dv._get(a, dv.args('key.0'), true) - dv._get(b, dv.args('key.0'), true);
      });
      toReturn = sortable;
    }

    if (!toReturn.length) {
      dv.kill("Data for ".concat(dv.selector, " was filtered and all items are invalid for visualizing. check provided data keys and make sure they are correct"));
    }

    return toReturn;
  };

  var _drawGraphSet2 = function _drawGraphSet2(classPrefix) {
    var dv = this;
    var graphSet = dv.g.selectAll("g.".concat(classPrefix)).data(dv.readyData(), function (dat) {
      return dat.parent;
    }).enter().append('g').attr('class', function (dat) {
      return "".concat(classPrefix, "\n\t\t\t\t\t\t").concat(dv.createClass('', "data-group-".concat(dat.parent, " ").concat(classPrefix, "-set"), dat.parent && dat.key));
    }).attr('transform', function () {
      return dv._is_base('pie') ? "translate( ".concat(dv.Pi().offset('x'), " , ").concat(dv.Pi().offset('y'), " )") : '';
    });
    graphSet.exit().transition(10) //DO NOT
    .style('opacity', 0).remove();
  };

  return DataVisualizer;

})));
//# sourceMappingURL=dataVisualizer.min.js.map
